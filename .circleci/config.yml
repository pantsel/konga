version: 2
defaults: &defaults
    working_directory: /tmp/persist_to_workspace
    docker:
      - image: 324148959017.dkr.ecr.us-east-1.amazonaws.com/repo-img-cci:latest
        aws_auth:
          aws_access_key_id: $ECR_AWS_ACCESS_ACCESS_KEY
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY

jobs:
  checkout:
    <<: *defaults
    steps:
     - checkout
     - run: pwd
     - run: ls -lart
     - persist_to_workspace:
         root: /tmp/persist_to_workspace
         paths:
            - .

  sourceclear:
    <<: *defaults
    steps:
     - attach_workspace:
         at: /tmp/persist_to_workspace
     - run:
        name: Source Clear - Vulnerability Issues
        command: |
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git
            cp GitOps/circleci/workflows/sourceclear/sourceclear.sh . 
            chmod +x sourceclear.sh
            ./sourceclear.sh
        no_output_timeout: 5m

  build_docker:
    <<: *defaults
    steps:
     - attach_workspace:
        at: /tmp/persist_to_workspace
     - setup_remote_docker:
        docker_layer_caching: true
     - run:
        name: Build Docker
        command: |
            # Clone GitOps
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git
            tag_name=$(jq --raw-output '.global.service.tag_name' < ServiceDefinitions.json)
            tag_environment=$(jq --raw-output '.global.service.qas.service.tag_environment' < ServiceDefinitions.json)
            task_revision=GIT-"$GITHUB_VERSION"-CI-"$CIRCLE_BUILD_NUM"-ENV-"$tag_environment"
            docker build -t "$tag_name":"$task_revision" --build-arg KONGA_PG_HOST=$KONGA_QAS_PG_HOST --build-arg KONGA_PG_USER=$KONGA_QAS_PG_USER --build-arg KONGA_PG_PASSWORD=$KONGA_QAS_PG_PASSWORD --build-arg KONGA_PG_DATABASE=$KONGA_QAS_PG_DATABASE --build-arg KONGA_NODE_ENV=production --build-arg KONGA_TOKEN=$KONGA_QAS_TOKEN .
            docker image ls
     - persist_to_workspace:
        root: /tmp/persist_to_workspace
        paths:
            - .
        no_output_timeout: 5m

  create-release:
    <<: *defaults
    steps:
     - attach_workspace:
        at: /tmp/persist_to_workspace
     - run:
        name: Creating a New Release on GitHub
        command: |
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git
            cp GitOps/circleci/workflows/release/release.sh . 
            chmod +x release.sh
            ./release.sh
        no_output_timeout: 5m

  deploy-qas:
    <<: *defaults
    steps:
     - attach_workspace:
        at: /tmp/persist_to_workspace
     - setup_remote_docker:
        docker_layer_caching: true
     - deploy:
        name: AWS - Pushing to Quality Environment
        command: |
            # Clone GitOps
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git

            echo "Deploy Quality Environment with Terraform ServiceDefinitions.json"
            # validate  ServiceDefinitions.json file
            schema_validation=$(json validate --schema-file GitOps/circleci/workflows/deploy/ServiceDefinitions-Schema.json --document-file ServiceDefinitions.json 2>&1 | sed 1,10d)
            if [ ! -z "$schema_validation" ]; then
              echo "Invalid JSON file: ServiceDefinitions.json"
              echo $schema_validation
              exit 1
            fi
          
            # terraform ServiceDefinitions.json > terraform.tfvars
            aws_region=$(jq --raw-output '.global.aws.aws_region' < ServiceDefinitions.json)
            aws_account=$(jq --raw-output '.global.aws.aws_account' < ServiceDefinitions.json)
            gitops_bucket=$(jq --raw-output '.global.aws.gitops_bucket' < ServiceDefinitions.json)
            gitops_region=$(jq --raw-output '.global.aws.gitops_region' < ServiceDefinitions.json)
            certificate_arn=$(jq --raw-output '.global.aws.certificate_arn' < ServiceDefinitions.json)
            cloudwatch_notification=$(jq --raw-output '.global.aws.cloudwatch_notification' < ServiceDefinitions.json)
            tag_name=$(jq --raw-output '.global.service.tag_name' < ServiceDefinitions.json)
            tag_resource=$(jq --raw-output '.global.service.tag_resource' < ServiceDefinitions.json)
            tag_client=$(jq --raw-output '.global.service.tag_client' < ServiceDefinitions.json)
            tag_environment=$(jq --raw-output '.global.service.qas.service.tag_environment' < ServiceDefinitions.json)
            container_port=$(jq --raw-output '.global.service.container_port' < ServiceDefinitions.json)
            container_memory=$(jq --raw-output '.global.service.qas.service.container_memory' < ServiceDefinitions.json)
            container_memory_reservation=$(jq --raw-output '.global.service.qas.service.container_memory_reservation' < ServiceDefinitions.json)
            desired_containers=$(jq --raw-output '.global.service.qas.service.desired_containers' < ServiceDefinitions.json)
            min_containers=$(jq --raw-output '.global.service.qas.service.min_containers' < ServiceDefinitions.json)
            max_containers=$(jq --raw-output '.global.service.qas.service.max_containers' < ServiceDefinitions.json)
            cpu_utilization_alarm=$(jq --raw-output '.global.service.qas.service.cpu_utilization_alarm' < ServiceDefinitions.json)
            memory_utilization_alarm=$(jq --raw-output '.global.service.qas.service.memory_utilization_alarm' < ServiceDefinitions.json)
            task_count_alarm=$(jq --raw-output '.global.service.qas.service.task_count_alarm' < ServiceDefinitions.json)
            health_check=$(jq --raw-output '.global.service.health_check' < ServiceDefinitions.json)
            ingress_cidr_blocks=$(jq --raw-output '.global.service.ingress_cidr_blocks' < ServiceDefinitions.json)
            ingress_ipv6_cidr_blocks=$(jq --raw-output '.global.service.ingress_ipv6_cidr_blocks' < ServiceDefinitions.json)
            internal=$(jq --raw-output '.global.service.internal' < ServiceDefinitions.json)
          
            # aws login
            aws configure set region "$aws_region"
            $(aws ecr get-login --region "$aws_region" --no-include-email)
          
            # create repository if not exists
            aws ecr describe-repositories --repository-names "$tag_name" 2>/dev/null 
            status=$?
            if [[ ! "${status}" -eq 0 ]]; then
                aws ecr create-repository --repository-name "$tag_name"
            fi
          
            # set revision
            task_revision=GIT-"$GITHUB_VERSION"-CI-"$CIRCLE_BUILD_NUM"-ENV-"$tag_environment"
          
            # docker build
            docker build -t "$tag_name":"$task_revision" --build-arg KONGA_PG_HOST=$KONGA_QAS_PG_HOST --build-arg KONGA_PG_USER=$KONGA_QAS_PG_USER --build-arg KONGA_PG_PASSWORD=$KONGA_QAS_PG_PASSWORD --build-arg KONGA_PG_DATABASE=$KONGA_QAS_PG_DATABASE --build-arg KONGA_NODE_ENV=production --build-arg KONGA_TOKEN=$KONGA_QAS_TOKEN .
            docker image ls
          
            # push docker image
            docker tag "$tag_name":"$task_revision" "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            docker push "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            
            # terraform init
            cd terraform || exit
            echo "aws_region = \"$aws_region\"
            aws_account = \"$aws_account\"
            gitops_bucket = \"$gitops_bucket\"
            gitops_region = \"$gitops_region\"
            certificate_arn = \"$certificate_arn\"
            cloudwatch_notification = \"$cloudwatch_notification\"
            tag_name = \"$tag_name\"
            tag_resource = \"$tag_resource\"
            tag_client = \"$tag_client\"
            tag_environment = \"$tag_environment\"
            container_port = \"$container_port\"
            container_memory = \"$container_memory\"
            container_memory_reservation = \"$container_memory_reservation\"
            desired_containers = \"$desired_containers\"
            min_containers = \"$min_containers\"
            max_containers = \"$max_containers\"
            cpu_utilization_alarm = \"$cpu_utilization_alarm\"
            memory_utilization_alarm = \"$memory_utilization_alarm\"
            task_count_alarm = \"$task_count_alarm\"
            health_check = \"$health_check\"
            internal = \"$internal\"
            ingress_cidr_blocks = $ingress_cidr_blocks
            ingress_ipv6_cidr_blocks = $ingress_ipv6_cidr_blocks" > terraform.tfvars
            terraform init -backend-config "bucket=$gitops_bucket" -backend-config "region=$gitops_region" -backend-config "key=terraform/aws/$aws_region/$tag_environment/ecs/services/$tag_name/main.tfstate"
          
            # terraform deploy
            terraform apply -var task_revision="$task_revision" -auto-approve
            # terraform plan
            echo "Done."
            
  deploy-stg:
    <<: *defaults
    steps:
     - attach_workspace:
        at: /tmp/persist_to_workspace
     - setup_remote_docker:
        docker_layer_caching: true
     - deploy:
        name: AWS - Pushing to Staging Environment
        command: |
            # Clone GitOps
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git

            echo "Deploy Staging Environment with Terraform ServiceDefinitions.json"
            # validate  ServiceDefinitions.json file
            schema_validation=$(json validate --schema-file GitOps/circleci/workflows/deploy/ServiceDefinitions-Schema.json --document-file ServiceDefinitions.json 2>&1 | sed 1,10d)
            if [ ! -z "$schema_validation" ]; then
              echo "Invalid JSON file: ServiceDefinitions.json"
              echo $schema_validation
              exit 1
            fi
          
            # terraform ServiceDefinitions.json > terraform.tfvars
            aws_region=$(jq --raw-output '.global.aws.aws_region' < ServiceDefinitions.json)
            aws_account=$(jq --raw-output '.global.aws.aws_account' < ServiceDefinitions.json)
            gitops_bucket=$(jq --raw-output '.global.aws.gitops_bucket' < ServiceDefinitions.json)
            gitops_region=$(jq --raw-output '.global.aws.gitops_region' < ServiceDefinitions.json)
            certificate_arn=$(jq --raw-output '.global.aws.certificate_arn' < ServiceDefinitions.json)
            cloudwatch_notification=$(jq --raw-output '.global.aws.cloudwatch_notification' < ServiceDefinitions.json)
            tag_name=$(jq --raw-output '.global.service.tag_name' < ServiceDefinitions.json)
            tag_resource=$(jq --raw-output '.global.service.tag_resource' < ServiceDefinitions.json)
            tag_client=$(jq --raw-output '.global.service.tag_client' < ServiceDefinitions.json)
            tag_environment=$(jq --raw-output '.global.service.stg.service.tag_environment' < ServiceDefinitions.json)
            container_port=$(jq --raw-output '.global.service.container_port' < ServiceDefinitions.json)
            container_memory=$(jq --raw-output '.global.service.stg.service.container_memory' < ServiceDefinitions.json)
            container_memory_reservation=$(jq --raw-output '.global.service.stg.service.container_memory_reservation' < ServiceDefinitions.json)
            desired_containers=$(jq --raw-output '.global.service.stg.service.desired_containers' < ServiceDefinitions.json)
            min_containers=$(jq --raw-output '.global.service.stg.service.min_containers' < ServiceDefinitions.json)
            max_containers=$(jq --raw-output '.global.service.stg.service.max_containers' < ServiceDefinitions.json)
            cpu_utilization_alarm=$(jq --raw-output '.global.service.stg.service.cpu_utilization_alarm' < ServiceDefinitions.json)
            memory_utilization_alarm=$(jq --raw-output '.global.service.stg.service.memory_utilization_alarm' < ServiceDefinitions.json)
            task_count_alarm=$(jq --raw-output '.global.service.stg.service.task_count_alarm' < ServiceDefinitions.json)
            health_check=$(jq --raw-output '.global.service.health_check' < ServiceDefinitions.json)
            ingress_cidr_blocks=$(jq --raw-output '.global.service.ingress_cidr_blocks' < ServiceDefinitions.json)
            ingress_ipv6_cidr_blocks=$(jq --raw-output '.global.service.ingress_ipv6_cidr_blocks' < ServiceDefinitions.json)
            internal=$(jq --raw-output '.global.service.internal' < ServiceDefinitions.json)
          
            # aws login
            aws configure set region "$aws_region"
            $(aws ecr get-login --region "$aws_region" --no-include-email)
          
            # create repository if not exists
            aws ecr describe-repositories --repository-names "$tag_name" 2>/dev/null 
            status=$?
            if [[ ! "${status}" -eq 0 ]]; then
                aws ecr create-repository --repository-name "$tag_name"
            fi
          
            # set revision
            task_revision=GIT-"$GITHUB_VERSION"-CI-"$CIRCLE_BUILD_NUM"-ENV-"$tag_environment"
          
            # docker build
            docker build -t "$tag_name":"$task_revision" --build-arg KONGA_PG_HOST=$KONGA_STG_PG_HOST --build-arg KONGA_PG_USER=$KONGA_STG_PG_USER --build-arg KONGA_PG_PASSWORD=$KONGA_STG_PG_PASSWORD --build-arg KONGA_PG_DATABASE=$KONGA_STG_PG_DATABASE --build-arg KONGA_NODE_ENV=production --build-arg KONGA_TOKEN=$KONGA_STG_TOKEN .
            docker image ls
          
            # push docker image
            docker tag "$tag_name":"$task_revision" "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            docker push "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            
            # terraform init
            cd terraform || exit
            echo "aws_region = \"$aws_region\"
            aws_account = \"$aws_account\"
            gitops_bucket = \"$gitops_bucket\"
            gitops_region = \"$gitops_region\"
            certificate_arn = \"$certificate_arn\"
            cloudwatch_notification = \"$cloudwatch_notification\"
            tag_name = \"$tag_name\"
            tag_resource = \"$tag_resource\"
            tag_client = \"$tag_client\"
            tag_environment = \"$tag_environment\"
            container_port = \"$container_port\"
            container_memory = \"$container_memory\"
            container_memory_reservation = \"$container_memory_reservation\"
            desired_containers = \"$desired_containers\"
            min_containers = \"$min_containers\"
            max_containers = \"$max_containers\"
            cpu_utilization_alarm = \"$cpu_utilization_alarm\"
            memory_utilization_alarm = \"$memory_utilization_alarm\"
            task_count_alarm = \"$task_count_alarm\"
            health_check = \"$health_check\"
            internal = \"$internal\"
            ingress_cidr_blocks = $ingress_cidr_blocks
            ingress_ipv6_cidr_blocks = $ingress_ipv6_cidr_blocks" > terraform.tfvars
            terraform init -backend-config "bucket=$gitops_bucket" -backend-config "region=$gitops_region" -backend-config "key=terraform/aws/$aws_region/$tag_environment/ecs/services/$tag_name/main.tfstate"
          
            # terraform deploy
            terraform apply -var task_revision="$task_revision" -auto-approve
            # terraform plan
            echo "Done."

  deploy-prd:
    <<: *defaults
    steps:
     - attach_workspace:
        at: /tmp/persist_to_workspace
     - setup_remote_docker:
        docker_layer_caching: true
     - deploy:
        name: AWS - Pushing to Production Environment
        command: |
            # Clone GitOps
            rm -rf GitOps
            mkdir -p ~/.ssh/
            ssh-keyscan github.com >> ~/.ssh/known_hosts
            git clone -b feature/sa-east-1 git@github.com:GitJMSeguradora/GitOps.git

            echo "Deploy Production Environment with Terraform ServiceDefinitions.json"
            # validate  ServiceDefinitions.json file
            schema_validation=$(json validate --schema-file GitOps/circleci/workflows/deploy/ServiceDefinitions-Schema.json --document-file ServiceDefinitions.json 2>&1 | sed 1,10d)
            if [ ! -z "$schema_validation" ]; then
              echo "Invalid JSON file: ServiceDefinitions.json"
              echo $schema_validation
              exit 1
            fi
          
            # terraform ServiceDefinitions.json > terraform.tfvars
            aws_region=$(jq --raw-output '.global.aws.aws_region' < ServiceDefinitions.json)
            aws_account=$(jq --raw-output '.global.aws.aws_account' < ServiceDefinitions.json)
            gitops_bucket=$(jq --raw-output '.global.aws.gitops_bucket' < ServiceDefinitions.json)
            gitops_region=$(jq --raw-output '.global.aws.gitops_region' < ServiceDefinitions.json)
            certificate_arn=$(jq --raw-output '.global.aws.certificate_arn' < ServiceDefinitions.json)
            cloudwatch_notification=$(jq --raw-output '.global.aws.cloudwatch_notification' < ServiceDefinitions.json)
            tag_name=$(jq --raw-output '.global.service.tag_name' < ServiceDefinitions.json)
            tag_resource=$(jq --raw-output '.global.service.tag_resource' < ServiceDefinitions.json)
            tag_client=$(jq --raw-output '.global.service.tag_client' < ServiceDefinitions.json)
            tag_environment=$(jq --raw-output '.global.service.prd.service.tag_environment' < ServiceDefinitions.json)
            container_port=$(jq --raw-output '.global.service.container_port' < ServiceDefinitions.json)
            container_memory=$(jq --raw-output '.global.service.prd.service.container_memory' < ServiceDefinitions.json)
            container_memory_reservation=$(jq --raw-output '.global.service.prd.service.container_memory_reservation' < ServiceDefinitions.json)
            desired_containers=$(jq --raw-output '.global.service.prd.service.desired_containers' < ServiceDefinitions.json)
            min_containers=$(jq --raw-output '.global.service.prd.service.min_containers' < ServiceDefinitions.json)
            max_containers=$(jq --raw-output '.global.service.prd.service.max_containers' < ServiceDefinitions.json)
            cpu_utilization_alarm=$(jq --raw-output '.global.service.prd.service.cpu_utilization_alarm' < ServiceDefinitions.json)
            memory_utilization_alarm=$(jq --raw-output '.global.service.prd.service.memory_utilization_alarm' < ServiceDefinitions.json)
            task_count_alarm=$(jq --raw-output '.global.service.prd.service.task_count_alarm' < ServiceDefinitions.json)
            health_check=$(jq --raw-output '.global.service.health_check' < ServiceDefinitions.json)
            ingress_cidr_blocks=$(jq --raw-output '.global.service.ingress_cidr_blocks' < ServiceDefinitions.json)
            ingress_ipv6_cidr_blocks=$(jq --raw-output '.global.service.ingress_ipv6_cidr_blocks' < ServiceDefinitions.json)
            internal=$(jq --raw-output '.global.service.internal' < ServiceDefinitions.json)
          
            # aws login
            aws configure set region "$aws_region"
            $(aws ecr get-login --region "$aws_region" --no-include-email)
          
            # create repository if not exists
            aws ecr describe-repositories --repository-names "$tag_name" 2>/dev/null 
            status=$?
            if [[ ! "${status}" -eq 0 ]]; then
                aws ecr create-repository --repository-name "$tag_name"
            fi
          
            # set revision
            task_revision=GIT-"$GITHUB_VERSION"-CI-"$CIRCLE_BUILD_NUM"-ENV-"$tag_environment"
          
            # docker build
            docker build -t "$tag_name":"$task_revision" --build-arg KONGA_PG_HOST=$KONGA_PRD_PG_HOST --build-arg KONGA_PG_USER=$KONGA_PRD_PG_USER --build-arg KONGA_PG_PASSWORD=$KONGA_PRD_PG_PASSWORD --build-arg KONGA_PG_DATABASE=$KONGA_PRD_PG_DATABASE --build-arg KONGA_NODE_ENV=production --build-arg KONGA_TOKEN=$KONGA_PRD_TOKEN .
            docker image ls
          
            # push docker image
            docker tag "$tag_name":"$task_revision" "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            docker push "$aws_account".dkr.ecr."$aws_region".amazonaws.com/"$tag_name":"$task_revision"
            
            # terraform init
            cd terraform || exit
            echo "aws_region = \"$aws_region\"
            aws_account = \"$aws_account\"
            gitops_bucket = \"$gitops_bucket\"
            gitops_region = \"$gitops_region\"
            certificate_arn = \"$certificate_arn\"
            cloudwatch_notification = \"$cloudwatch_notification\"
            tag_name = \"$tag_name\"
            tag_resource = \"$tag_resource\"
            tag_client = \"$tag_client\"
            tag_environment = \"$tag_environment\"
            container_port = \"$container_port\"
            container_memory = \"$container_memory\"
            container_memory_reservation = \"$container_memory_reservation\"
            desired_containers = \"$desired_containers\"
            min_containers = \"$min_containers\"
            max_containers = \"$max_containers\"
            cpu_utilization_alarm = \"$cpu_utilization_alarm\"
            memory_utilization_alarm = \"$memory_utilization_alarm\"
            task_count_alarm = \"$task_count_alarm\"
            health_check = \"$health_check\"
            internal = \"$internal\"
            ingress_cidr_blocks = $ingress_cidr_blocks
            ingress_ipv6_cidr_blocks = $ingress_ipv6_cidr_blocks" > terraform.tfvars
            terraform init -backend-config "bucket=$gitops_bucket" -backend-config "region=$gitops_region" -backend-config "key=terraform/aws/$aws_region/$tag_environment/ecs/services/$tag_name/main.tfstate"
          
            # terraform deploy
            terraform apply -var task_revision="$task_revision" -auto-approve
            # terraform plan
            echo "Done."            

workflows:
  version: 2
  workflow-project:
    jobs:
      - checkout:
          context: GitJMSeguradora
      - sourceclear:
          context: GitJMSeguradora
          requires:
            - checkout
      - build_docker:
          context: GitJMSeguradora
          requires:
            - sourceclear
      - create-release:
          context: GitJMSeguradora
          requires:
            - build_docker
          filters:
            branches: { only: 'master' }   # Ignore all branches except master
            tags: { only: '/.*/' }         # All tags
      - approve-qas:
          type: approval 
          filters:
            branches: { ignore: 'master' }   # Ignore branches master
            tags: { only: '/.*/' }         # All tags
      - deploy-qas:
          context: GitJMSeguradora
          filters:
            branches: { ignore: 'master' }   # Ignore branches master
            tags: { only: '/.*/' }         # All tags
          requires:
            - build_docker
            - create-release
            - approve-qas
      - approve-stg:
          type: approval 
          filters:
            branches: { only: 'master' }   # Ignore all branches except master
            tags: { only: '/.*/' }         # All tags
      - deploy-stg:
          context: GitJMSeguradora
          filters:
            branches: { only: 'master' }   # Ignore all branches except master
            tags: { only: '/.*/' }         # All tags
          requires:
            - build_docker
            - create-release
            - approve-stg
      - deploy-prd:
          context: GitJMSeguradora
          filters:
            branches: { only: 'master' }   # Ignore all branches except master
            tags: { only: '/.*/' }         # All tags
          requires:
            - approve-prd
            - build_docker
            - create-release
            - deploy-stg
      - approve-prd:
          type: approval
          filters:
            branches: { only: 'master' }    # Ignore all branches except master
            tags: { only: '/.*/' }          # All tags
